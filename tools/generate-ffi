#!/usr/bin/env runhaskell
-- -*- haskell -*-
--
-- Generates a low-level FFI interface to CBlas using c2hs.
--
{-# LANGUAGE NoMonomorphismRestriction #-}
module Main where
import Data.List (intercalate)
import Text.Printf (printf)
import Defs

main :: IO ()
main = do
  let dir = "../src/Blas/Primitive"
  writeFile (dir ++ "/Safe.chs.tmp")   $ ffiFuncModule funInsts
  writeFile (dir ++ "/Unsafe.chs.tmp") $ ffiFuncModule funInstsUnsafe

ffiModule exports contents =
  rubyVars $
  [ ("exports",  intercalate ", "   exports)
  , ("contents", intercalate "\n\n" contents) ]

ffiEnumModule enums = ffiModule (fmap (++ "(..)") enums) (fmap mkEnum enums)
ffiFuncModule funcs = ffiModule (fmap cfName funcs)      (fmap mkFun funcs)

-- | Convert a set of global Ruby variables into a string.
--   Note: the values are not escaped.
rubyVars :: [(String, String)] -> String
rubyVars = intercalate "\n\n" . (fmap $ uncurry $ printf "$%s = %%[%s]\n")

-- | Generates a c2hs hook for the enumeration.
mkEnum :: String -> String
mkEnum name =
  printf ("{# enum %s as %s {} with prefix = \"%s\"%s #}")
         (enumMangler name) name enumValuePrefix derivings
  where derivings = " deriving (Bounded, Eq, Ord, Read, Show)"

-- | Generates a c2hs hook for the function.
mkFun :: CFun -> String
mkFun (CFun safe name params ret doc) =
  (if null doc then "" else "-- | " ++ doc) ++
  printf "{# fun%s %s%s { %s } -> %s #}"
         safe' cName hName params' ret'
  where cName   = funMangler name
        hName   = if name == cName then "" else " as " ++ name
        safe'   = if safe then "" else " unsafe"
        params' = intercalate ", " $ fmap (mkParamType . convType) params
        ret'    = mkRetType $ convType ret
