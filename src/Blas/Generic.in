#{# -*- haskell -*-
require "./tools/common"
stem = strip_ext FILE
name = File.basename stem
["Safe", "Unsafe"].each do |safety|
  write_file "#{stem}/#{safety}.hs", <<END
#{AUTOGEN}
{-# LANGUAGE FlexibleInstances, TypeFamilies #-}
{-|

Stability: experimental

Generic interface to Blas using #{safety.downcase} foreign calls.  Refer to
the GHC documentation for more information regarding appropriate use of safe
and unsafe foreign calls.

The functions here are named in a similar fashion to the original Blas
interface, with the type-dependent letter(s) removed.  Some functions have
been merged with others to allow the interface to work on both real and
complex numbers.  If you can't a particular function, try looking for its
corresponding complex equivalent (e.g. @symv@ is a special case of 'hemv'
applied to real numbers).

It'd be really nice if these functions were actually documented.  Alas, for
the time being, you'll have to refer to the various Blas docs scattered across
the Internet.  Note that the interface is based off of /CBlas/, not Fortran
Blas, which is slightly different.

-}
module Blas.#{name}.#{safety}
       ( Numeric(..)
       , RealNumeric(..)
       , D.dsdot
       , S.sdsdot
       ) where
import Data.Complex (Complex)
import Foreign (Ptr, Storable)
import Blas.Primitive.Types (Order, Transpose, Uplo, Diag, Side)
import qualified Blas.Specialized.Float.#{safety} as S
import qualified Blas.Specialized.Double.#{safety} as D
import qualified Blas.Specialized.ComplexFloat.#{safety} as C
import qualified Blas.Specialized.ComplexDouble.#{safety} as Z

-- | Blas operations that are applicable to real and complex numbers.
--
--   Instances are defined for the 4 types supported by Blas: the
--   single- and double-precision floating point types and their complex
--   versions.
class (Floating a, Storable a) => Numeric a where

  -- | The corresponding real type of @a@.
  --
  --   In other words, @'RealType' ('Complex' a)@ is an alias for @a@.  For
  --   everything else, @'RealType' a@ is simply @a@.
  type RealType a :: *

  dotu  :: Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
  dotc  :: Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
  nrm2  :: Int -> Ptr a -> Int -> IO (RealType a)
  asum  :: Int -> Ptr a -> Int -> IO (RealType a)
  iamax :: Int -> Ptr a -> Int -> IO Int
  swap  :: Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
  copy  :: Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
  axpy  :: Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
  scal  :: Int -> a -> Ptr a -> Int -> IO ()
  gemv  :: Order -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a
        -> Int -> a -> Ptr a -> Int -> IO ()
  gbmv  :: Order -> Transpose -> Int -> Int -> Int -> Int -> a -> Ptr a
        -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
  trmv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  tbmv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a
        -> Int -> Ptr a -> Int -> IO ()
  tpmv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a
        -> Int -> IO ()
  trsv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  tbsv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a
        -> Int -> Ptr a -> Int -> IO ()
  tpsv  :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a
        -> Int -> IO ()
  hemv  :: Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int
        -> a -> Ptr a -> Int -> IO ()
  hbmv  :: Order -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a
        -> Int -> a -> Ptr a -> Int -> IO ()
  hpmv  :: Order -> Uplo -> Int -> a -> Ptr a -> Ptr a -> Int -> a
        -> Ptr a -> Int -> IO ()
  geru  :: Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  gerc  :: Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  her   :: Order -> Uplo -> Int -> RealType a -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  hpr   :: Order -> Uplo -> Int -> RealType a -> Ptr a -> Int
        -> Ptr a -> IO ()
  her2  :: Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int
        -> Ptr a -> Int -> IO ()
  hpr2  :: Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int
        -> Ptr a -> IO ()

  -- | Calculate a general matrix-matrix product:
  --
  --   > c := alpha * opa(a) * opb(b) + beta * c
  --
  --   where `opa` and `opb` are operations specified by @transa@ and
  --   @transb@ respectively.
  gemm  :: Order     -- ^ Layout of all matrices.
        -> Transpose -- ^ (@transa@) Operation applied to @a@.
        -> Transpose -- ^ (@transb@) Operation applied to @b@.
        -> Int       -- ^ (@m@) Number of rows of @opa(a)@ and @c@.
        -> Int       -- ^ (@n@) Number of columns of @opb(b)@ and @c@.
        -> Int       -- ^ (@k@) Number of columns of @opa(a)@ and
                     --         number of of rows of @opb(b)@.
        -> a         -- ^ (@alpha@) Scaling factor of the product.
        -> Ptr a     -- ^ (@a@) Pointer to a matrix.
        -> Int       -- ^ (@lda@) Stride of the major dimension of @a@.
        -> Ptr a     -- ^ (@b@) Pointer to a matrix.
        -> Int       -- ^ (@ldb@) Stride of the major dimension of @b@.
        -> a         -- ^ (@beta@) Scaling factor of the original @c@.
        -> Ptr a     -- ^ (@c@) Pointer to a mutable matrix.
        -> Int       -- ^ (@ldc@) Stride of the major dimension of @c@.
        -> IO ()

  symm  :: Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int
        -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
  syrk  :: Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int
        -> a -> Ptr a -> Int -> IO ()
  syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int
        -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
  hemm  :: Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int
        -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
  herk  :: Order -> Uplo -> Transpose -> Int -> Int -> RealType a -> Ptr a
        -> Int -> RealType a -> Ptr a -> Int -> IO ()
  her2k :: Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int
        -> Ptr a -> Int -> RealType a -> Ptr a -> Int -> IO ()
  trmm  :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int
        -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
  trsm  :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int
        -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()

-- | Blas operations that are only applicable to real numbers.
--
--   Note: although complex versions of 'rot' and 'rotg' exist in many
--   implementations, they are not part of the official Blas standard and
--   therefore not included here.  If you /really/ need them, submit a ticket
--   so we can try to come up with a solution.
class Numeric a => RealNumeric a where
  rotg  :: Ptr a -> Ptr a -> Ptr a -> Ptr a -> IO ()
  rotmg :: Ptr a -> Ptr a -> Ptr a -> a -> Ptr a -> IO ()
  rot   :: Int -> Ptr a -> Int -> Ptr a -> Int -> a -> a -> IO ()
  rotm  :: Int -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> IO ()

#{ [
  ["Float", "Float", "s"],
  ["Double", "Double", "d"],
  ["Complex Float", "Float", "c"],
  ["Complex Double", "Double", "z"],
].map do |num_type, real_type, abbrev|
  paren_type = (num_type.include? " ") ? "(" + num_type + ")" : num_type
  is_real    = real_type == num_type
  <<END

#{ if is_real then <<END
instance RealNumeric #{paren_type} where
  rotg  = #{abbrev.upcase}.rotg
  rotmg = #{abbrev.upcase}.rotmg
  rot   = #{abbrev.upcase}.rot
  rotm  = #{abbrev.upcase}.rotm
END
end }

instance Numeric #{paren_type} where
  type RealType #{paren_type} = #{real_type}
  dotu  = #{abbrev.upcase}.dotu
  dotc  = #{abbrev.upcase}.dotc
  nrm2  = #{abbrev.upcase}.nrm2
  asum  = #{abbrev.upcase}.asum
  iamax = #{abbrev.upcase}.iamax
  swap  = #{abbrev.upcase}.swap
  copy  = #{abbrev.upcase}.copy
  axpy  = #{abbrev.upcase}.axpy
  scal  = #{abbrev.upcase}.scal
  gemv  = #{abbrev.upcase}.gemv
  gbmv  = #{abbrev.upcase}.gbmv
  trmv  = #{abbrev.upcase}.trmv
  tbmv  = #{abbrev.upcase}.tbmv
  tpmv  = #{abbrev.upcase}.tpmv
  trsv  = #{abbrev.upcase}.trsv
  tbsv  = #{abbrev.upcase}.tbsv
  tpsv  = #{abbrev.upcase}.tpsv
  hemv  = #{abbrev.upcase}.hemv
  hbmv  = #{abbrev.upcase}.hbmv
  hpmv  = #{abbrev.upcase}.hpmv
  geru  = #{abbrev.upcase}.geru
  gerc  = #{abbrev.upcase}.gerc
  her   = #{abbrev.upcase}.her
  hpr   = #{abbrev.upcase}.hpr
  her2  = #{abbrev.upcase}.her2
  hpr2  = #{abbrev.upcase}.hpr2
  gemm  = #{abbrev.upcase}.gemm
  symm  = #{abbrev.upcase}.symm
  hemm  = #{abbrev.upcase}.hemm
  syrk  = #{abbrev.upcase}.syrk
  herk  = #{abbrev.upcase}.herk
  syr2k = #{abbrev.upcase}.syr2k
  her2k = #{abbrev.upcase}.her2k
  trmm  = #{abbrev.upcase}.trmm
  trsm  = #{abbrev.upcase}.trsm

END
end.join("") }

END
end }
